

> #### Effective Java 3/E
> 2020-05-25
>
> 아이템 #06 불필요한 객체 생성을 피하라

<br><br><br><br><br>





# 06. 불필요한 객체 생성을 피하라

같은 기능의 객체를 매번 생성하기보다는 **`객체 하나를 재사용`**하는 편이 나을 때가 많다.
빠르고 세련되기 떄문.

* 특히 **`불변 객체`**(아이템 17)는 언제든 재사용가능
* 생성자 대신 팩토리 메소드(아이템 1)을 제공하는 불변 클래스에서는 **`정적 팩토리 메소드`**를 사용
	* 불변 객체 뿐 아니라, 가변 객체라고 해도 사용중에 변경되지 않을 것임을 안다면 재사용 가능
* 생성 비용이 비싼 객체가 반복해서 필요하다면 **`캐싱`**해서 재사용
* 오토박싱 피하기


<br><br>


## 인스턴스 재사용

#### 부적절한 예
``` java
String no = new String("hello");
```
- 실행될 때마다 String 인스턴스를 새로 만듦
- 반복문 / 빈번하게 호출되는 메소드 안에 있다면 쓸데없는 String 인스턴스가 수백만 개 만들어질 수도 있음


#### 개선된 예
``` java
String yes = "hello";
```

- 하나의 String 인스턴스를 사용
- 같은 가상 머신 안에서 같은 문자열 리터럴을 사용하는 모든 코드가 같은 객체를 재사용함이 보장됨

<br><br>



## 정적 팩토리 메소드
생성자 대신 정적 팩토리 메소드를 제공하는 불변 클래스에서는 정적 팩토리 메소드를 이용해 불필요한 객체 생성을 피할 수 있다.

#### 부적절한 예
``` java
Boolean(String)
```
- 호출할 때마다 새로운 객체를 만듦


#### 적절한 예
``` java
Boolean.valueOf(String)
```
- 같은 객체를 재사용할 수 있음


> #### 참고
> 이 생성자(Boolean())는 자바 9에서 deprecated API로 지정되었다.


<br><br>


## 캐싱
생성 비용이 아주 비싼 객체가 반복해서 필요하다면 캐싱해서 재사용

- 빨라지고
- 코드가 명확해진다.


#### 예1 - String.maches()는 성능이 중요한 상황에서 반복해 사용하기에 적절하지 않다
``` java
static boolean isRomanNumeral(String s) {
	return s.matches("^(?=.)M*(C[MD]|D?C{0,3})"
		+ "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
}
```
- 이 메소드가 내부적으로 만드는 Pattern 메소드는 한 번 쓰고 버려져서 바로 가비지 컬렉션 대상이 된다
- Pattern은 인스턴스 생성 비용이 높다
	- 입력받은 정규표현식에 해당하는 FSM(Finite State Machine, 유한 상태 머신)을 만들기 때문

#### 개선 포인트
- (필요한 정규식을 표현하는 불변하는) Pattern 인스턴스를 클래스 초기화 (정적 초기화) 과정에서 직접 생성해 캐싱
- 나중에 *isRomanNumeral()* 메소드가 호출될 때마다 인스턴스를 재사용


#### 예2 - 값비싼 객체를 재사용
``` java
public class RomanNumerals {
	// static final 로 설정함으로써 코드의 의미가 더 잘 드러난다.
	private static final Pattern ROMAN = Pattern.compile(
		"^(?=.)M*(C[MD]|D?C{0,3})"
		+ "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");

	static boolean isRomanNumeral(String s) {
		return ROMAN.macher(s).maches();
	}
}
```
- 이 방식에서 클래스가 초기화된 후 *isRomanNumerla*이 한 번도 호출되지 않는다면  ROMAN 필드는 쓸데없이 초기화된 꼴이 됨
- 메소드가 처음 호출될 때 필드를 초기화하는 지연 초기화(lazy initialization, 아이템 83)로 불필요한 초기화를 없앨 수는 있지만, 권하지는 않는다.
- 성능은 크게 개선되지 않을 때가 많기 때문


> #### 참고
> 저자의 컴퓨터에서 길이가 8인 문자열을 입력했을 때
> * 개선 전 (예1) 1.1µs
> * 개선 후 (예2) 0.17µs
> 1µs＝10-6s.


<br><br>


## 객체가  불변한지 불명확하다면? 직관에 반대된다면?

어댑터(뷰 View)의 경우

* 어댑터 = 실제 작업은 뒷단 객체에 위암하고, 자신은 제2의 인터페이스 역할을 해주는 객체
* 뒷단 객체 하나당 어댑터 하나씩만 만들어지면 충분
	* 뒷단 객체 외에는 관리할 상태가 없기 때문


#### 예
Map의 인터페이스 KeySet 메소드는 Map 객체 안의 키 전부를 담은 Set 뷰를 반환
- 구현할 때 매번 같은 객체를 반환해도 될 것 (기능이 같기 때문)
- 즉, 반환한 객체 중 하나를 수정하면 다른 모든 객체가 따라서 바뀐다. (같은 객체를 바라보고 있기 때문)


<br><br>



## 오토박싱 (auto boxing)
오토박싱: 프로그래머가 기본 타입(int, long 등)과 박싱된 기본 타입(Integer, Long)을 섞어 쓸 때 자동으로 상호 변환해주는 기술

* 오토박싱은 기본 타입과 그에 대응하는 박싱된 기본 타입의 구분을 흐려주지만, 완전히 없애주는 것은 아니다.
* 의미 상으로는 별다를 것 없지만, 성능에서는 그렇지 않다.

``` java
private static long sum() {
	Long sum = 0L;
	for(long i = 0; i<= Integer.MAX_VALUE; i++)
		sum += i;
	return sum;
}
```

<details>
  <summary>문제가 되는 부분 보기</summary>
  <p>
	  Long sum (박싱된 타입) 이 아닌, <br>
	  long sum (기본 타입)으로 선언했어야 함
  </p>
</details>


<br><br><br>



* 이번 아이템은 "객체 생성은 비싸니 피해야 한다"가 아니다.
	* JVM에서는 별다른 일을 하지 않는 작은 객체를 생성하고 회수하는 일이 크게 부담되지 않는다.
	* 프로그램의 명확성, 간결성, 기능을 위해 객체를 추가로 생성하는 것이라면 일반적으로 좋은 일이다.

* 거꾸로, 아주 무거운 객체가 아닌 다음에야 단순히 객체 생성을 피하고자 자신만의 객체 풀(pool)을 만들지 말자.
	* 예외: DB같은 경우 생성 비용이 워낙 비싸므로 재사용하는 편이 낫다
	* 일반적으로는 자체 객체 풀은 
		* 코드를 헷갈리게 만들고 
		* 메모리 사용량을 늘리고 
		* 성능을 떨어뜨린다.

* 이번 아이템 = 기존 객체를 재사용해야 한다면 새로운 객체를 만들지 마라
* 아이템 50 (방어적 복사) = 새로운 객체를 만들어야 한다면 기존 객체를 재사용하지 마라
	* 데이터가 바뀌었을 수도 있으니까~
* 방어적 복사에 실패하면 => 언제 터져 나올지 모르는 버그와 보안 구멍
* 불필요한 객체 생성 => 코드 형태와 성능에만 영향



