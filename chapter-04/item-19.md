#### Effective Java 3/E
> 2020-06-08
>
> 아이템 #19 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

<br><br><br><br><br>


## 1. 문서화하라

상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다.

* 그리고 문서화한 내용을 지켜야 한다.
* 그렇지 않으면 (지키지 않으면) 하위 클래스를 오동작하게 만들 수 있다.

그럼?

* 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다.
* 상속용 클래스의 **생성자** 는 직접적으로든 간접적으로든 **재정의 가능 메소드**를 호출해서는 안 된다.
  - 어기면 오동작할 것
  - **부모 생성자 -> 자식 생성자** 순서로 호출됨
  - **하위 클래스에서 재정의한 메소드 -> 하위 클래스 생성자** 순서로 호출됨

``` java
public class Super {
    // [!] 생성자가 재정의가능 메소드를 호출한다.
    public Super() {
        오버라이드();
    }
    
    public void 오버라이드() {
    }
}


public final class Sub extends Super {
    private final Instant instant;
    
    Sub() {
        instant = Instant.now();
    }
    
    // 상위 클래스(Super)의 생성자가 호출한다.
    @Override
    public void 오버라이드() {
        System.out.println(instant);
    }
    
    public static void main(String[] args) {
        Sub sub = new Sub();  // null
        sub.오버라이드();     // 값
    }
}
```

- instant를 두 번 출력할 것 같지만?
- instant는 final 필드이지만 위 코드에서는 상태가 두 개이다. 처음에 null이 출력된다.
- (부모 클래스 -> 자식 클래스 순서로 호출됨)

#### 실행 순서
* main()에서 Sub() 호출
* Sub()
  - Sub()의 맨 윗줄에서 super() 호출
* (부모 클래스인) Super() 호출
  - Super() 안에서 오버라이드() 호출
  - Sub.오버라이드()가 호출됨
    - instant(초기화되기 전) 값 프린트
  - Super() 종료
* Sub()로 돌아옴
* Sub() 안에서 오버라이드() 호출
  - Instant 초기화
  - Sub() 종료
* main()으로 돌아옴
* 오버라이드 호출
  - 초기화된 instant 값 프린트


<br>

> #### 참고
> * private, final, static 메소드는 재정의 불가능
> * 생성자에서 호출해도 된다.


<br><br><br>

## 2. (그러지 않았다면) 상속을 금지하라

* 상속용으로 설계하지 않은 클래스는 상속을 금지

#### 상속을 금지하는 방법
1. 클래스를 final로 선언
2. 모든 생성자를 private나 package-private(default)로 선언하고 public 정적 팩토리를 만들어주는 방법

#### 상속하고 싶다면
* 클래스 내부에서는 재정의 가능 (override할 수 있는) 메소드를 사용하지 않게 만들고 이 사실을 문서로 남기기
  - 재정의 가능 메소드를 호출하는 자기 사용 코드를 완벽히 제거하라는 뜻
  - 이렇게 하면 메소드를 재정의해도 다른 메소드의 동작에 영향을 주지 않기 때문
* 클래스의 동작을 유지하면서 재정의 가능 메소드를 사용하는 코드를 제거할 수 있는 기계적인 방법
  - 각각의 재정의 가능 메소드는 자신의 본문 코드를 private '도우미 메소드'로 옮긴다
  - (재정의 가능 메소드가) 이 '도우미 메소드'를 호출하도록 수정한다
  - 재정의 가능 메소드를 호출하는 다른 코드들도 모두 이 '도우미 메소드'를 호출하도록 수정





